# 语法

## 标识符

标识符有一个字母开头，其后可加一个或多个字母、数字或下划线。不允许使用保留字。

undefined,NaN和Infinity却不是保留字。JS不允许使用保留字来命名参数或者变量，也不允许在对象字面量中，或者再一个属性存取表达式的点号之后，使用保留字作为对象的属性名。

## 没有用的注释比没有注释更糟糕，注释是为了说明你的代码为什么要这样写，而不是许多人所理解的那样只简单地说明代码做了什么。由于块注释（/* */）的有些字符可能出现在正则表达式上，而正则表达式也有可能是被注释的内容，例如下面这段代码：

	/* 
	    var rm_a = /a*/.match(s);  
	*/  

所以不建议使用/* */注释，而采用//替代它。

## JavaScript中，数字只有一个类型——64位的浮点数。

	alert(1 === 1.0); // true

## NaN表示一个不能产生正常结果的运算结果，它也是一个number类型的值。所以

	typeof(NaN)  === 'number'; //true

NaN不等于任何值，包括它自己。

	console.log(NaN == NaN); // false

用isNaN( number )检测一个运算结果是否为NaN。

## Infinity也是一个number类型的值，所以：

typeof(Infinity)==='number'; //true

isNaN(Infinity)===false; //true

Infinity所表示的是所有大于1.79769313486231570e+308的值。

## JavaScript的字符串有一个length属性。

	console.log('abcdefg'.length); //7

## 关于其它类型转换为布尔类型的规则：

（1）undefined and null are always false.

（2）Booleans are just treated as booleans (obviously).

（3）Numbers are false if they equal 0 or NaN; otherwise, they’re true.

（4）Strings are true, except for the empty string "", which is false.

（5）Objects are always true.

下面这些值在进行条件判断时，都会被当作为假（false）：

false、null、undefined、空字符串' '、数字0、数字NaN，

其他所有的值被当作真，包括true、字符串"false"，以及所有的对象。

但是要注意，这是执行条件判断语句或者&&、||、!、?等运算符转换后的结果，如果直接用== 或 === 运算符进行比较，结果则又大不一样。

	false === false; //true
	null == false; //false
	undefined == false; //false
	'' == false; //true
	'' === false; //false
	0 == false; //true
	0 === false; //false
	0 == ''; //true
	0 === ''; //false
	0 == undefined; //false
	0 == null; //false
	undefined == null; //true
	undefined === null; //false

此外，请注意：

	false == 'false';  //false
	true == 'true';  //false
	'false' == true; //false
	'true' == false; //false

这种比较的确很让人崩溃。

JS中的“==”符号及布尔值转换规则

what are the rules for how == converts types?

关于"=="的比较规则：

(1) null and undefined will always equal each other.

null类型与undefined类型比较始终相等(==)。如：

	var a = null，b; //则 a==b 为true。

(2) Comparing numbers and strings will always convert the strings to numbers. 

number类型与string类型比较，string会转换为number类型。如：

	2=="2"; //true

(3) Comparing booleans to any other type will always cause the booleans to be converted to numbers.

布尔类型与其它任何类型进行比较，布尔类型将会转换为number类型。如：

	var a = 0, b = false; //则a==b为true

(4) Comparing numbers or strings to objects will always cause the numbers or strings to be converted to objects.

number类型或者string类型与object类型进行比较，number或者string类型都会转换为object类型。如：

	var a = 0, b = {}; //则a==b为false

The rules for converting other types to booleans are actually relatively straightforward:

只要记住null只和undefined相等（==），对象只与它本身相等，有number都转number，有boolean都转number，有string都转string，NaN互相不等就可以了。？？？

JS对象的比较是引用的比较，非值的比较，对象只和其本身相等，和其它任何对象不相等。 

因为对象只与它本身相等，所以：

var a={}, b={};
a == b; //false

===（严格相等运算符）首先计算其操作数的值，然后比较，比较过程无任何类型转换。

## JavaScript不允许在return关键字和表达式之间换行。

## typeof运算符产生的值有6种：'number'、'string'、'boolean'、'undefined'、'function'、'object'。

## + 运算符可以进行加法运算或字符串连接。如果要进行加法运算，必须确保两个运算数必须都是数字。

## 在Javascript中定义一个函数，有两种写法：

	function foo() { }

和

	var foo = function () { }

两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。

## 语句

 语句的执行顺序：从上到下。JS可用过条件语句（if,switch），循环语句（fo,while,do），强制跳转语句（return,break,throw）和函数调用来改变执行顺序。  for循环有两种形式，

 	for(var i=0; i < arr.length,i++){}

 和

 	for(var i in arr){}

 后者枚举一个对象的所有属性名（或键名），在每次循环中，对象的另一个属性名字符串被复制给for和in之间的变量。 object.hasOwnProperty(variable)来检测是否为该对象的成员，还是从原型链里找到的。

for ... in语句不仅还会输出对象原型链上的属性。如下所示：

Object.prototype.bar = 1; 
var foo = {moo: 2}; 
for(var i in foo) { 
	console.log(i); // 输出 bar 和 moo 
} 

所以需要用hasOwnProperty()来进行过滤：

for(myvar in obj){
     if(obj.hasOwnProperty(myvar)){
         ...
     }
}

JS不允许在return关键字和表示式之间换行,同样不允许break关键字和标签之间换行。

## 表达式

最简单的表达式是字面量值（比如字符串或数字）、变量、内置的值（true、false、null、undefined、NaN和Infinity）、以new前导的调用表达式、以delete前导的属性存取表达式、包在圆括号中的表达式、以一个前缀运算符作为前导的表达式，或者表达式后面跟着：

一个插入运算符与另一个表达式；
三元运算符?后面跟着另一个表达式，然后接一个:，再然后接第三个表达式；
一个函数调用；
一个属性存取表达式。
函数调用引发函数的执行，函数调用运算符是跟随在函数名后面的一对圆括号。圆括号中可能包含将会传递给这个函数的参数。一个属性存取表达式用于指定一个对象或数组的属性或元素。

下表按从最高到最低的优先级列出JavaScript运算符。具有相同优先级的运算符按从左至右的顺序求值。

运算符	描述
. [] ()	字段访问、数组下标、函数调用以及表达式分组
++ – - ~ ! delete new typeof void	一元运算符、返回数据类型、对象创建、未定义值。其中typeof
运算符产生的值有'number'、'string'、'boolean'、'undefined'、'function'和'object'（注意都是小写）如果运算数是一个数组或null,那么结果是‘object’。可以通过Array.isArray(arr)来判断数组；可以通过obj===null来判断obj是否为null。
/ % 乘法、除法、取模
+ - 加法/字符串连接、减法
<< >> >>>	移位
< <= > >= instanceof	小于、小于等于、大于、大于等于、instanceof
== != === !==	等于、不等于、严格相等、非严格相等
&	按位与
^	按位异或
|	按位或
&&	逻辑与
||	逻辑或
?:	条件
= oP=	赋值、运算赋值
,	多重求值


# 对象

JavaScript中简单类型包括数字、字符串、布尔值、null值和undefined，其他所有的值都为对象（数组是对象，函数是对象，正则表达式是对象，对象当然也是对象）。String,Number,Boolean“貌似”对象，因为他们它们有自己的方法，但他们是不可变的。JavaScript中对象是可变的键控组合（keyed collections）。对象是属性的容器，其中每个属性都拥有名字和数值，属性的名字可是包括空字符串在内的任意字符串，而属性值可是除undefined值之外的任意值。JavaScript包括一个原型链特性，允许对象继承另一个对象的属性，正确的地使用它能减少对象初始化的时间和内存消耗。

## 3.1 对象字变量
对象字面量提供了一种非常方便地创建新对象值的表示法。一个对象字面量就是包围在一对花括号中的零或多个“名/值”.对象字面量可出现在任何允许表达式出现的地方。

在对象字面量中，如果属性名是一个合法的JavaScript标识符且不是保留字，并不强制要求用引号括住属性名。所以用引号括住“fisrt-name”是必须的（因为含‘-’这个属性名不是合法的JS标识符，见上一章标识符定义“标示符有一个字母开头，其后可加一个或多个字母、数字或下划线，不允许使用保留字。”），而是否用引号括住first_name则是可选的了。
            
## 3.2 检索

要检索对象中包含的值，可以采用在[]后缀中括住一个字符串表达式的方式。若字符串是一个常数且他是一个合法的JavaScript标识符而非保留字,那么也可以用.表示法代替，优先使用.表示法，因为更紧凑可读性更好。

      stooge["first-name"] //Chouchou
      flight.departure.city //"Kuala Lumpu"
            
若检索一个并不存在的成员元素的值，则返回undefined。

||运算符可以用来填充默认值

	var status=flight.status||"unkown";
                
尝试检索一个undefined值的属性或方法将会导致TypeError异常。可通过&&避免错误。
                    
      flight.equipment//undefined
      flight.equipment.model//throw "TypeError"
      flight.equipment&&flight.equipment.model//undefined
                    
                
## 3.3 更新

对象中的值可以通过赋值语句来更新，若属性名已经存在于对象中，那么该属性的值被更新；如果对象之前并未拥有这个属性名，则该属性会被添加到该对象中。

## 3.4 引用

对象通过引用来传递。它们永远不会被拷贝。

      var x=chouchou;
      x.nickname='huang';
      var nick=chouchou.nickname;
      //因为x和chouchou是指向同一个对象的引用，所以nick也为'huang'
      var a={},b={},c={};
      //a,b,c每个都引用不同的空对象。
      a=b=c={};
      //a,b,c都引用同一个空对象。
            
## 3.5 原型（prototype）

每一个对象都连接到一个原型对象，并且它可以从中继承。所有通过对象字面量创建的对象都连接到Object.prototype这个JavaScript的标准对象。

当创建一个新对象时，可选择某个对象作为它的原型。这个给Object增加一个beget （音：[bɪˈget]）自定义方法，beget方法创建一个使用原对象作为其原型的新对象。
      
      //因为方法是添加到Object 对象上，它会对全局产生影响，所以先判断一下是否有别的地方已经对Object对象定义过同名的属性。

	if(typeof Object.beget !== 'function') {
		Object.beget = function (o) {
		   var F=function () {};
		   F.prototype=o;
		   return new F(); 
		}
	}
	var another_chouchou=Object.beget(chouchou);
                
            
当我们对某个对象做出改变时，不会触及到该对象的原型。原型连接只有在检索值时才被用到，如果我们尝试去获取对象的某个属性值，且该对象没有此属性名，则JavaScript试着从原型对象中获取属性值。如果那个原型对象也没有该属性，则从它的原型中寻找，依次类推，直到终点Object.prototype。

如果想要的属性完全不在原型链中则返回undefined。这个过程称为委托。

原型关系是一种动态的关系。若我们添加一个新的属性到原型中，则该属性会立即对所有基于该原型创建的对象可见。

      chouchou.profession="front-end develoer";
      another_chouchou.profession;//"frond-end developer"
                
## 3.6 反射

检查对象并确定有什么属性很容易，只要试着去检索该属性并验证所取得的值。可用typeof，但是原型链中的任何属性也会产生一个值，例如

      typeof flight.toString //'function'
      typeof flight.constructor //'function'
            
有两个方法去除这些不必要的属性。第一，让你的程序检查并剔除函数值。一般来说，做反射的目标是数据。因此你应该意识到一些值可能会是函数。 第二，用hasOwnProperty方法。如果对象拥有独立属性返回true。hasOwnProperty不会检查原型链。

## 3.7 枚举

for in 语句可用来遍历一个对象中所有的属性名。该枚举过程将会列出所有的属性，包括函数和你可能不关心原型链中的属性。所以我们需要过滤，常用的过滤器是hasOwnProperty以及typeof来排除函数。 属性名出现顺序不确定，要以确定的顺序来输出的话，应该创建一个数组，在其中以正确的顺序包含属性名。

	var i;
	var properties=[
		'fistr-name',
		'middle-name',
		'last-name'
		'profession'
	];
	for(i = 0; i < properties.length;i +=1 ){
		document.writeln(properties[i]+':'+
		another.chouchou[propertites[i]]);
	}
                
## 3.8 删除

delete运算符可以用来删除对象的属性。它不会触及原型链中的任何对象。删除对象的属性可能让来自原型链中的属性浮现出来。

      another.chouchou.nickname //'me'
      delete another.chouchou.nickname;
      another.chouchou.nickname // 'huang'
                
## 3.9 减少全局变量污染

JavaScript可以很随意的定义哪些可保存所有应用资源的全局变量。但全局变量减弱了程序的灵活性，应予以避免。最小化使用全局变量的方法是在你的应用中只创建一个全局变量。

var MYAPP={};
该变量此时编程了你的应用的容器。

	MYAPP.chouchou={
        "first-name":"Chouchou",
        "last-name":"Shouchouchou"
	};

	MYAPP.flight={
		airline="mh",
		number=370,
		departure：{
		    IATA:"KL"，
		    time:"2014-03-08 00:25",
		    city:"Kuala Lumpu"
		},
		arrival:{
		    IATA:"CN"，
		    time:"future",
		    city:"Beijing"
		}
	};

只有把多个全局变量都整理在一个名称空间下，你将显著降低与其他应用程序，组件或类库之间产生糟糕的相互影响的可能性。下一章将介绍闭包来有效减少全局污染。


＃ 函数

函数包含一组语句，他们是JavaScript的基础模块单元，用于代码复用、信息隐藏和组合调用。函数用于指定对象的行为。

## 4.1 函数对象

JavaScript中函数就是对象。 对象字面量产生的对象连接到 Object.prototype。函数对象连接到Function.prototype（该原型对象本身连接到Object.prototype）。每个函数在创建时附有两个附加的隐藏属性：函数的上下文和实现函数行为的代码（JavaScript创建一个函数对象时会为该对象设置一个“调用”属性，当JS调用该函数时，可理解为JS调用此函数的“调用”属性）。函数与其它对象的不同之处在于它可以被调用。

## 4.2 函数字面量

函数对象可以通过函数字面量来创建：

//创建一个名字add的变量，并用来把两数字想家的函数赋值给它。
var add = function (a, b) {
    return a + b;
};

函数有四部分构成：function保留字； 函数名，可省略（匿名函数），函数可以用它的名字来递归调用自己；（）中的参数；{}中的语句。

函数字面量可出现在任何允许表达式出现的地方。函数可以被定义在其他函数中。一个内部函数自然可以访问自己的参数和变量。同时它也能方便地访问它被嵌套在其中的函数的参数与变量。

## 4.3 调用

调用一个函数将暂停当前函数的执行，传递控制权和参数给新被调用的函数。除声明时定义的形参外，每个函数接收两个附加的参数：this和arguments。在面向对象中，this值取决于调用模式。

JavaScript有四种调用模式：方法调用、函数调用、构造器调用、apply调用模式。这些模式在如何初始化关键参数this存在差异。调用运算符是跟在任何产生一个函数值的表达式之后的一对圆括号。圆括号内可包含零或多个用逗号隔开的表达式，每个表达式产生一个参数值。每个参数值被赋予函数声明时定义的形参名（就是实参传进函数）。当实参（arguments）与形参（parameters）个数不匹配时不会导致运行错误。若实参多了则多的忽略，若少了则少的传给形参的实参值定义为undefined。对参数不进行类型检查。

（1）方法调用模式

当一个函数被保存为对象的一个属性时，成为方法。当一个方法被调用时，this被绑定到该对象。如果一个调用表达式包含一个属性存取表达式（即一个点表达式或[subscript]下标表达式），那么它被当做一个方法来调用（很好理解）。

	var myObject = {
		value : 0,//注意这里是逗号，书上是分号
		increment : function (inc) {
		  this.value += typeof inc === 'number' ? inc : 1;
		}
	};
	myObject.increment();
	document.writeln(myObject.value); //1
	myObject.increment(2);
	document.writeln(myObject.value); //3

方法可使用this去访问对象，故其能从对象中取值或修改该对象。this到对象的绑定发生在调用时（very late binding），这使得函数可以对this高度复用。通过this可取的所属对象的上下文的方法称为公共方法。

（2）函数调用模式

当一个函数并非一个对象的属性时，它就当做一个函数来调用。

	var sum = add(3, 4);//sum值为7 

当函数以此模式调用时，this被绑定到全局对象（语言设计上的错误）。正确设计应为当内部函数被调用时，this应该仍然绑定到外部函数的this变量。导致方法不能利用内部函数来帮助它工作。因为内部函数的this被绑定了错误的值，所以不能共享该方法对对象的访问权限。解决方法，定义一个that变量并把它赋值给this,那么内部函数就可以通过that访问this了。

	//给myObject 增加一个 double 方法
	myObject.double = function () {
	    var that = this;//解决方法
	    var helper = function () {
	       that.value = add(that.value,that.value);
	    };
	    helper();//以函数的形式调用helper
	};
	//以方法的形式调用doule
	myObject.double();
	document.writeln(myObject.getValue());//6
	构造器调用模式

JavaScript基于原型继承的语言，但是不自信，所以提供了基于类的语言类似的对象构建语法。

如果在一个函数前加上 new 来调用，那么将创建一个隐藏链接到该函数的prototype成员的新对象，同时this将会绑定到这个新对象上。（new 也会改变 return 语句的行为）

	//创建一个名为Quo的构造器函数，它创造一个带有status属性的值。
	var Quo =function (string) {
	    this.status = string;
	};
	//给Quo的所有实例提供一个名为 get_status 的公共 方法。
	Quo.prototype.get_status = function () {
	     return this.status;
	 }
	//构造一个Quo实例
	var myQuo =new Quo("confused");
	document.writeln(myQuo.get_status()); //confused;
	不推荐这种方式。

（3）Apply调用模式

JavaScript是一门函数式的面向对象编程语言，所以函数可以用方法。 apply方法让我们构建一个参数数组并用其去调用函数，它也允许我们选择this的值。apply方法接收两个参数，第一个是将被绑定给this的值，第二个是一个参数数组。

	 //构建一个包含两个数字的数组，并且将他们想加

	var array = [3, 4];
	var sum = add.apply(null, array); //sum值为7

	//构造一个包含status成员对象
	var statusObeject = {
	    status ：'A-OK'
	 };

	 //statusObeject并没有继承自 Quo.prototype,但我们可以在statusObeject上调用get_status方法。
	 //尽管statusObeject并没有一个名为get_status的方法。

	var status = Quo.prototype.get_status.apply(statusObeject);
	//status值为OK

## 4.4 参数

当一个函数调用时，会得到一个arguments数组，通过arguments函数可访问它被调用时传递给它的参数列表，包括哪些未被分配给函数声明时定义的形参的多余参数。

	var sum = function () {
	    var i, sum=0;
	    for (var i = 0; i < arguments.length; i++) {
	         sum += arguments[i];
	    }
	    return sum;
	};
	document.writeln(sum(4,8,12,13));//37

注意arguments只是一个array-like对象，其拥有一个length属性，但缺少所有的数组方法，并不是真正的数组。

## 4.5 返回

当一个函数被调用时，return语句被执行时函数立即返回而不再执行余下的部分。一个函数总是返回一个值，如果没指定则为undefined。如果函数以前加上new出来的，且返回值不是一个对象，则返回 this(该新对象)。

## 4.6 异常

异常是干扰程序的正常流程的非正常（但并未完全出乎意料的）事故。当查出这样的事故时，程序抛出异常。

	var add = function (a,b){
	    if (typeof a !== 'number'||typeof b !== 'number'){
	        throw {
	            name: 'TypeError',
	            message: 'add needs numbers'
	         };
	     }
	     return a + b;
	  }

throw语句中断函数执行，应该抛出一个exception对象，该对象包含可识别异常类型的name属性和一个描述性的message属性。也可添加其他属性。 该exception对象将被传递给一个try语句的catch语句。

	var add = function (a,b) {
	    if (typeof a !== 'number'||typeof b !== 'number'){
	       throw {
	           name: 'TypeError',
	           message: 'add needs numbers'
	       };
	   }
	   return a + b;
	 }
	var try_it = function () {
	    try {
	        add("seven");
	   } catch (e) {
	       document.writeln(e.name + ":" + e.message);
	   }
	}
	try_it();

## 4.7 给类型增加方法

JavaScript允许给语言的基本类型增加方法。如第三章，我们通过Object.prototype添加方法是的该方法对所有对象可用。
这样的方法对函数、数组、字符串、数字和正则表达式和布尔值同样适用。

例如我们可通过给Fundation.prototype增加方法使得所有函数都有这个方法。

	Function.prototype.method = funtion (name,func) {
	    this.prototype[name] = func;
	    return this;
	 }

通过给Fundation.prototype增加一个method方法，我们就不必键入prototype这个属性名了。

我们还可以用过给Number.prototype添加一个integer方法来重写JavaScript中的取整方法。它会根据数字的正负来判断使用Math.floor（向下取整）或者Math.ceiling（向上取整）。

	Number.method('integer',function(){
	    return Math[this<0?'ceil':'floor'](this);
	});
	document.writeln((-10/3).integer());//-3

	 //移除字符串末端空白的方法
	 String.method('trim',function() {
	     return this.replace(/^\s+|\s+$/g,'');
	  });
	  document.writeln('"' + "     neat   ".trim() + '"');

通过给基本类型增加方法，可大大提高语言表现力。基于JS原型继承的动态本质，新的方法立刻被赋予到所有的值（对象实例）上，哪怕值（对象实例）是在创建之前就创建好了。

基本类型的原型是公共的机构，在类库混用时应小心。一个保险的做法是指在确定没有该方法时才添加他。

	//有条件的增加一个方法
	Function.prototype.method = function (name,func) {
		if (!this.prototype[name]) {
	     		this.prototype[name] = func;
	     }
	 };

另外要注意for in语句在原型上表现很糟糕可参考第三章的解决办法。

## 4. 8 递归

递归函数是一种会直接或间接的调用自身的函数。

//Hanoi问题

递归函数可以非常高效的操作树形结构，比如浏览器的DOM。每次递归调用时处理给定树的一小段。


	//walk_the_DOM函数，它从某个给定结点开始，按HTML源码中顺序访问该树的每个节点。
	//它会调用一个函数，并依此传递每个节点给它，walk_the_DOM调用自身去处理每一个子节点。
	var walk_the_DOM = function walk(node,func){
	    func(node);
	    node=node.firstChild;
	    while (node) {
	        walk (node, func){
	            node=node.nextSibling;
	        }
	    }
	};


	//getElementByAttribute取得属性名字符串和一个可选的匹配值
	//他调用walk_the_DOM 传递一个用来查找节点属性名的函数
	//匹配的节点会累积到一个结果数组。
	var getElementByAttribute = function (att, value) {
	    var results = [];
	    walk_the_DOM(document.body, function (node) {
	        var actual = node.nodeType === 1&& node.getAttribute(att);
	        if(typeof actual === 'string' && (actual === value || typeof value !== 'string')) {
	            results.push(node);
	        }
	    });
	    return results;
	}

	尾递归优化，即如果一个函数返回自身递归调用的结果，那么调用的过程会被替换为一个循环。可惜JS不提供，深度递归的函数可能会因为返回堆栈溢出而运行失败。

	var factorial = function factorial (i, a) {
	   a = a || 1;
	    if (i <2) {
	        return a;
	    }
	    return factorial(i-1, a*i);
	}
	 document.writeln(factorial(4));//24

## 4.9 作用域

JS并不是支持块作用域！ JS具有函数作用域！因为没有块作用域，最好在函数体顶部声明所有需要用到的变量。（这里涉及到函数提升和变量提升。）

## 4.10 闭包（Closure）

好的，重点来了。上节说了JavaScript没有块作用域，只有函数作用域，作用域的好处是内部函数可以访问定义它们的外部函数的参数和变量（除了this和arguments）。更有趣的是，内部函数会拥有比其外部函数更长的生命周期:)。

	var myObeject = function () {
	    var value = 0;

	    return {
	        increment: function (inc) {
	            value += typeof inc === 'number' ? inc : 1;
	        },
	        getValue: function () {
	            return value;
	        }
	    }
	}();

这里通过调用一个函数的形式来初始化myObject,该函数将返回一个对象字面量。此函数定义了一个value变量。该变量对increment和getValue可用，但函数的作用域使得它对其他的程序来说是不可见的。这里要注意的是我们并没有把一个函数赋给myObject而是把调用这个函数后返回的结果赋值给myObject了（注意最后一行的（））。该函数返回一个包含两个方法的对象，并且这些方法继续享有访问value变量的特权。

	var quo = function (status) {
	    return {
	        get_status:function () {
	            return status;
	        }
	    };
	};
	var myQuo = quo("amazed"); //函数调用
	document.writeln(myQuo.get_status());

	//对比下之前的myQuo
	var Quo = function (string) {
	    this.status = string; 
	};
	Quo.prototype.get_status = function () {
	    return this.status;
	};
	var myQuo = new Quo("confused"); //构造器调用
	document.writeln(myQuo.get_status());

前面的quo函数被设计成无需在前面加上new来使用（所以它的名字没有首字母大写）。当我们调用quo时，它返回包含get_status方法的一个新都想。该对象的一个引用保存在myQuo中，即使quo已经返回了，但get_value方法仍然享有访问quo对象的status属性的特权。get_status方法并不是访问该参数的一个拷贝，它访问的就是该参数本身。因为该函数可以访问它**被创建时的上下文环境**。 this is closure.

	var fade = function (node) {
	    var level = 1;
	    var step = function () {
	        var hex = level.toString(16);
	        node.style.backgroundColor = '#FFFF' + hex + hex;
	        if (level < 15) {
	            level += 1;
	            setTimeout(step,100);
	        }
	    };
	    setTimeout(step,100);
	};
	fade(document.body);

分析下这段代码：我们调用fade,把document.body作为参数传递给它，fade函数设置level为1，它定义了一个step函数，接着它调用steTimeout,并传递step函数和一个时间（100毫秒）给它，然后它返回，fade函数结束。

在100毫秒之后step函数被调用。它把fade函数的level变量初始化为16进制。接着，它修改fade函数得到的节点的背景颜色。然后查看level的大小，如果level尚未变为白色（F）那么他增大fade函数的level变量和用setTimeout预定让它自己再次运行。step函数很快被再次调用。但这次levle变量值为2，fade函数在之前已经返回了，但只要fade的内部函数需要，它的变量就会持续保留。

再看一个糟糕的例子。


var add_the_handelers = function (nodes) {
    var i;
    for (var i = 0; i < nodes.length; i+=1) {
        nodes[i].onclick = function (e) {
            alert(e);
        }
    }
};

add_the_handlers函数目的是给每个事件处理器一个唯一值（i）。它未能达到目的是因为时间处理器函数绑定了变量i,而不是函数在构造时的变量的i。


	//更好的例子
	var add_the_handelers = function (nodes) {
	    var i;
	    for (var i = 0; i < nodes.length; i+=1) {
	        nodes[i].onclick = function (i) {
	            return function (e) {
	            alert(e);
	            };
	        }(i);
	    }
	};

现在我们定义了一个函数并立即传递i进去执行，而不是把一个函数赋值onclick。那个函数将返回一个事件处理器函数，这个事件处理器函数绑定的是传递进去的i的值。而不是定义在add_the_handlers函数里的i的值。那个被返回的函数被复制给onclick。


## 4.11 回调

函数可以让不连续事件的处理变得更容易。例如：假定有这么一个序列，由用户交互开始向服务器发送请求，最终显示服务器的响应，最纯朴的方法可能会是这样写的。

	request = prepare_the_request();
	response = send_request_synchronously(request);
	display(response);

同步请求易会导致客户端进入假死状态，响应性降低。来尝试异步请求。提供一个当服务器的响应到达时将被调用的回调函数。异步的函数立即返回，这样客户端不会被阻塞。

	request = prepare_the_request();
	response = send_request_synchronously(request,function(response){
	    display(response);
	});

我们传递了一个函数作为参数给send_request_synchronously函数，它将在收到响应时被调用。

## 4.12 模块

模块是一个提供接口但隐藏状态与实现的函数或者对象。我们可以使用函数和闭包来构造模块。通过使用函数构造模块，我们就可以完全摒弃全局变量的使用。

例如，我们要给String增加一个deentityify方法，其作用是寻找字符串中的HTML字符实体来替换为他们对应的字符。在一个对象中保存字符实体的名字和他们对应的字符是有意义的。我们在哪儿保存该对象呢。全局变量，oh,no,donnot give shit.我们可以把它定义在该函数本身，但是有运行时的小号，我们没执行一次函数该字面量就会被求值一次。理想的额方式是将其放入一个闭包中。而且也许还能提供一个增加更多字符实体的扩展方法。

	String.method('deentityify',function(){
	    //字符实体表，它映射字符实体的名字到对应的字符。
	    var entity = {
	        quot : '"',
	        lt : '<',
	        gt : '>',
	    };
	    //返回deetityify方法
	    return function () {
	        //这才是deetityify方法，它调用字符串的replace方法
	        //查找‘&’开头和‘;’结束的字符串。如果这些字符可以在字符实体表中找到
	        //那么久将该字符实体替换为映射表中的额值。

	        return this.replace(/&([^&;]+);/g,
	            function(a,b){
	                var r = entity[b];
	                return typeof r === 'string' ? r : a;
	            });
	    };
	}());
	//注意我们用（）运算法立即调用我们刚刚创建的函数。

	document.writeln('<"'.deentityify());

模块模式利用了函数作用域和闭包来创建绑定对象与私有成员的关联。在该例中只有deentityify方法有权访问字符实体表这个数据对象。

模块模式的一般形式是：宇哥定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数；或者把他们保存到一个可访问到的地方

模块模式也可以用来产生安全的对象。假定我们想要构造一个用来产生序列号的对象。

	//返回一个用来产生唯一字符串的对象
	//唯一字符串有两部分组成：前缀+序列号
	//该对象包含一个设置前缀的方法，一个设置序列号的方法
	//和一个产生唯一字符串的gensym方法
	var serial_maker = function () {
	    var prefix = '';
	    var seq = 0;
	    return {
	        set_prefix: function (p) {
	            prefix = String(p);
	        },
	        set_seq: function (s) {
	            seq = s;
	        },
	        gensym: function () {
	            var result = prefix + seq;
	            seq += 1;
	            return result;
	        }
	    };
	};

	var seqer =serial_maker();
	seqer.set_prefix('Q');
	seqer.set_seq(1000);
	var unique = seqer.gensym();

## 4.13 级联

有一些方法没有返回值，例如一些设置或修改对象的某个状态却不返回任何值的方法就是典型例子。如果我们让这些方法返回this而不是undefined,就可以启用级联。在一个级联中，我们可以在单独一条的语句中一次调用同一个对象的很多方法。一个启用级联的Ajax类库允许我们以这样的形式去编码。

	getElement('myBoxDiv').
	    move(350,150).
	    width(100).
	    height(100).
	    color('red').
	    appendText("Please donot give a shit!");
	    on('mousedown',function(m){
	        this.startDrag(m,this.getNinth(m));
	    }).
	    on('mousemove','drag').
	    later(2000,function(){
	        this.
	            color('yellow').
	            setHTML('What hath God wraught?').
	            slide(400,40,200,200)
	        }).
	    tip('this box is resizeable');

级联可以产生具备很强表现力的接口。它也能帮助控制那种构造试图一次做太多事情的接口的趋势。

## 4.14 套用

函数也是值，我们可以去操作函数值。套用允许我们将函数与传递给它的参数相结合去产生出一个新的函数。

	var add1 = add.curry(1);
	 document.writeln(add1(6));//7
	//curry见书P43

## 4.15 记忆

函数可以用对象去记住先前操作的结果->记忆。

	var fibonacci = function (n) {
	return n < 2 ? n:fibonacci(n-1)+fibonacci(n-2);
	}

	for (var i = 0; i<=10; i++){ 
	document.writeln('//'+i+':'+fibonacci(i));
	 }
	 //fibonacci函数被调用了453次。做了大量的重复工作
	 //我们在一个名为memo的数组里保存我们的存储结果，存储结果隐藏在闭包中
	 //当函数被调用时，这个函数首先看是否已经知道存储结果，若知道立即返回该存储结果。

	var fibonacci = function () {
	    var memo = [0, 1];
	    var fib = function (n) {
	        var result = memo[n];
	        if (typeof result !== 'number') {
	            result =fib(n-1)+fib(n-2);
	            memo[n] =result;
	        }
	        return result;
	    };
	    return fib;
	}();

	for (var i = 0; i<=10; i++){
	    document.writeln('//'+i+':'+fibonacci(i));
	}
	//该函数得到同样结果但却调用了29次。
	我们可以把这种形式一般化，编写一个函数来帮助我们构造带记忆功能的函数。 memoizer函数将取得一个初级的memo数组和fundamental函数，它返回一个管理meno存储和在需要时调用fundamental函数的shell函数。我们传递这个shell函数和该函数的参数给fundamental函数。


	var memoizer =  function (memo,fundamental) {
	    var shell = function (n) {
	        var result = memo[n];
	        if(typeof result !== 'number') {
	            result = fundamental(shell,n);
	            meno[n]=result;
	        }
	        return result;
	    };
	    return shell;
	};
	//x现在我们可以用memoizer来定义fibonancci函数
	var fibonacci = memoizer([0,1],function(shell,n){
	return shell(n-1)+shell(n-2);});

在这一章中，闭包是个不好理解的概念。下面引篇文章进行说明。

来源：http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html

闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。
下面就是我的学习笔记，对于Javascript初学者应该是很有用的。

一、变量的作用域

要理解闭包，首先必须理解Javascript特殊的变量作用域。
变量的作用域无非就是两种：全局变量和局部变量。
Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。

　　var n=999;
　　function f1(){
　　　　alert(n);
　　}
　　f1(); // 999

另一方面，在函数外部自然无法读取函数内的局部变量。

　　function f1(){
　　　　var n=999;
　　}
　　alert(n); // error

这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！

　　function f1(){
　　　　n=999;
　　}
　　f1();
　　alert(n); // 999

二、如何从外部读取局部变量？

出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。
那就是在函数的内部，再定义一个函数。

　　function f1(){
　　　　var n=999;
　　　　function f2(){
　　　　　　alert(n); // 999
　　　　}
　　}

在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！

　　function f1(){
　　　　var n=999;
　　　　function f2(){
　　　　　　alert(n); 
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999

三、闭包的概念

上一节代码中的f2函数，就是闭包。

各种专业文献上的"闭包"（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。
由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。
所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

四、闭包的用途

闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。
怎么来理解这句话呢？请看下面的代码。

　　function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000

在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。

为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。

五、使用闭包的注意点

1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

六、思考题

如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。
代码片段一。

　　var name = "The Window";
　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　return function(){
　　　　　　　　return this.name;
　　　　　　};
　　　　}
　　};
　　alert(object.getNameFunc()());

代码片段二。

　　var name = "The Window";
　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　var that = this;
　　　　　　return function(){
　　　　　　　　return that.name;
　　　　　　};
　　　　}
　　};
　　alert(object.getNameFunc()());


break、delete、function、return、typeof、case、do、if、switch、var、catch、else、in、this、void、continue、false、instanceof、throw、while、debugger、finally、new、true、const、with、default、for、null和try